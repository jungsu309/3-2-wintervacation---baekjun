T , W = map(int, input().split())

plum =[]
plum.append(0)#0초에는 아무것도 안떨어지니까! 1초부터 떨어지기 시작한다.
for t in range(T):
    plum.append(int(input()))
#print(plum)

#기억할 리스트 만들기 - 정답지에서 2차원을 만들라고 했으므로! dp[T][W]가 되도록 생성
dp=[[0]*(W+1) for _ in range(T+1)]#0번 인덱스 안쓴다고 생각하고 만들자. W의 경우 0(이동x)포지션도 잇으니까 1 추가
#print(dp)


for i in range(T+1):
    #맨 처음. (w=0)지금 자리에서 움직이지 않는다. -> 1번나무거만 받아먹을 수 있고 2번나무꺼는 다 못먹는다
    if plum[i] ==1:
        dp[i][0] = dp[i-1][0] + 1#움직이지 않고 방금 떨어진 자두를 한개 받아먹는다.
    else:#2번 나무에서 자두가 떨어지는경우. 움직이지 않으니까 먹을 수 없다.
        dp[i][0] = dp[i-1][0]
    #처음에 연속으로 같은나무에서 떨어질 수 있다. 그래서 i로 하는것.


    #이제부터 움직이기 시작할 것이다.
    for j in range(1,W+1):#아예 움직이지 않은 w=0은 위에서 이미 끈냄.
        if j>i:
            #자두(사람)는 1초에 한번 움직일 수 있으므로 i초에 i번보다 많이 움직일수는 없다.
            break
        #자두가 1번 나무에서 떨어지고 그것을 받아먹기
        #1번 나무 아래에 있어야 하므로, 이동을 짝수번 했어야 1번나무 자두를 받아먹을 수 있다.
        if plum[i] ==1 and j%2 ==0:
           #직전시간에 1번나무 밑에 있었거나, 아니면 2번나무 밑에 있어서 이동을 한번 해서 받아먹어야하거나 둘중하나임
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + 1#최대값을 구하는 것이므로 max를 이용하자..
        #자두가 2번 나무에서 떨어지고있고 그것을 받아먹기
        #내위치가 2번나무 아래에 있어야 받아먹을 수 있으므로, 홀수번 이동한 상태여야지 먹을수있다.
        elif plum[i]==2 and j%2==1:
            #직전에 그대로 2번나무에 있었거나 아니면 1번나무 밑에 있엇어서 한번 이동한 후 받아먹거나 둘중하나임.
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) +1

        #안먹기!
        else:
            #안먹으려면 이동하지 않고 안먹기 or 떨어지는곳을 피해서 다른곳으로 가서 안먹기
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-1])#안먹으니까 1 하지않기

#print(dp)
# 전부 다 하고 마지막 t초에 먹을 수 있는 자두의 최대값을 출력
print(max(dp[T]))
            
        

        
